# Homework 1

-----------------

## P1

数据结构是数据的**组织形式**；算法是对数据进行求值、查找、建立和求解模型等**操作的顶层设计**。数据结构和算法相辅相成，二者需要结合才能**发挥效能，提升计算效率，求解各种复杂的问题**。如果没有合适的数据结构提供高效、明晰的数据组织形式，算法效率的提高就无从谈起。如果没有算法在数据结构上运行，则复杂问题根本无法得到解决。

## P2

(1) 小问代码见 _[sorts.py]()_，(2) 小问代码见 *[sorts_recursive.py]()*

时间复杂度分析：

非递归的冒泡排序的主体是一个二重循环。循环主体如下：

```cpp
for i = 1 to n
	for j = 1 to n - i
		...
```

这个循环的运行次数为 $\displaystyle\sum_{i=1}^n (n-i) = \frac{n \times (n-1)}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$ 次。所以时间复杂度为 $\mathcal{O}(n^2)$。

因为每次待排序的数字都会减少一个，选择排序的运行次数也为  $\displaystyle\sum_{i=1}^n (n-i)$，复杂度也为 $\mathcal{O}(n^2)$。

插入排序的循环形如

```cpp
for i = 1 to n
	for j = 1 to i
		...
```

则其运行次数为 $\displaystyle\sum_{i=1}^n i = \frac{n\times (n+1)}{2} = \frac{1}{2}n^2 + \frac{1}{2} n$，复杂度也为 $\mathcal{O}(n^2)$。

递归形式的复杂度分析如下。这里分析冒泡排序的复杂度，其余二者同理。

$$T(i) = n - i + T(i-1), T(1) = n-1$$

算法的执行次数为 $T(n)$

$T(n) = T(n-1)$

$T(n-1) = 1 + T(n-2)$

$T(n-2) = 2 + T(n-3)$

$\cdots$

$T(1) = n - 1$

两侧相加求和，消去 $T(1) \sim T(n-1)$ 得：

$$T(n) = 1 + 2 + \cdots + (n-1) = \frac{n(n-1)}{2}$$

故时间复杂度为 $\mathcal{O}(n^2)$。

三个排序算法中，冒泡排序和插入排序只需要一个长度为 $n$ 的数组，则其空间复杂度为 $\mathcal{O}(n)$。

在我的实现中，选择排序需要两个，空间复杂度也为 $\mathcal{O}(n)$。

(3) 小问使用 _[datagen.cpp]()_ 生成测试数据。测试环境如下：

平台：Windows 10 ARM-64
CPU：AMD Ryzen 4800H @2.90GHz
编译器及解释器：MinGW-w64 GCC 8.1.0, Python 3.9.0

在 $n = 100, 1000, 4000$ 下分别运行三组测试数据，取运行时间平均值：

|  n | 冒泡排序 | 选择排序 | 插入排序 |
| :-:|:------:|:------:|:------:|
| 100|0.00034s|0.00020s|0.00020s|
|1000|0.04459s|0.01398s|0.01822s|
|4000|0.75209s|0.21060s|0.29706s|

考虑到数据文件大小不同，除去读写的时间消耗，可以得出，时间复杂度分析在误差允许范围内正确。

## P3

(1)(2) 小问代码见 _[hanoi.py]()_, _[hanoi_norecursive.py]()_

时间复杂度分析：

递归算法：

$$T(n) = 1 + 2T(n-1), T(1) = 1$$

记 $G(n) = T(n) + 1$，则 $G(n) = 2G(n-1), G(1) = 2$。

这是一个首项为 $1$ 的等差数列。应用求和公式得 $G(n) = 2^n$。

故 $T(n) = G(n) - 1  = 2^n - 1$

故汉诺塔问题的递归算法时间复杂度为 $\mathcal{O}(2^n)$。空间复杂度为 $\mathcal{O}(1)$。

非递归算法的主体部分为一个范围是 $[1, 2^n)$ 的循环，故时间复杂度为 $\mathcal{O}(2^n)$。空间复杂度为 $\mathcal{O}(1)$，与递归算法相同。

**若不考虑输出方案，只计算步数，则可以用公式计算答案，非递归算法的时间复杂度降为** $\mathcal{O}(n)$。

(3) 问：采用 $n=4, 12, 20$ 作为输入，运行三次取平均时间消耗，得到两份代码的运行时间消耗如下：

|  n |  递归 | 非递归 |
|:-:|:-----:|:------:|
| 4|0.08077s|0.06232s|
|12|0.92464s|0.94231s|
|20|4.81909s|4.76355s|

观察到算法的主要时间占用在于输出，故递归与非递归算法的效率差异可以忽略不计。

## P4

(1) 问代码见 _[Collatz.py]()_

(2) 问：角谷猜想（又名考拉兹猜想）现在**仍然是数学界有名的 Open Problem 之一**，故我无法断定其正误。

有的数学家认为，该猜想任何程度的解决都是现代数学的一大进步，将开辟全新的领域。

该问题最近的进展是 2019 年 12 月，陶哲轩证明只要 ${\displaystyle f(n)}$ 是一个趋于正无穷的实数列，那么几乎对所有的正整数 ${\displaystyle n}$ (在对数密度意义下) ，有 $\displaystyle S(n)<f(n)$。

## P5

(1) 问代码见 _[min_chromatic.cpp]()_

对任意交叉路口的"交通管制问题"，本质是求一般（简单）图上的一个最小点染色（Minimum Vertex Coloring）。这个问题是 reduection from 3-SAT 问题的，而后者是我们熟知的 NP-Complete 问题。

所以目前，求解此问题的最优时间复杂度是 $\mathcal{O}(n\times 2^n)$，该问题的优化形式也是 NP-Hard 的，计数形式则为 #P-Complete。

该贪心算法很容易在若干图下得到差距较大的结果，例如皇冠图、完全二分图和正则图等。它可以得到一个正确的点染色方案，但不一定为最小色数。

若想根据流量优化，则可以统计各个路口的流量数据，枚举结点时按此值从大到小调整枚举顺序，从而尽可能让流量大的路口先尽可能被染色，放大贪心的优势思路。